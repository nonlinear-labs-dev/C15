#include <catch.hpp>

#include <recorder/FlacFrameStorage.h>
#include <recorder/FlacDecoder.h>
#include <recorder/FlacEncoder.h>
#include <recorder/Recorder.h>
#include <recorder/RecorderInput.h>
#include <recorder/RecorderOutput.h>

#include <glibmm.h>

#include <algorithm>
#include <thread>
#include <recorder/Bitstream.h>

TEST_CASE("FlacDecoder")
{
  FlacFrameStorage storage(100000);
  FlacEncoder enc(48000, [&](auto frame, auto header) { storage.push(std::move(frame), header); });

  auto numFrames = 48000;
  SampleFrame buf[numFrames];
  std::fill(buf, buf + numFrames, SampleFrame { 0.0f, 0.0f });

  buf[0].left = 1.0f;
  buf[1].left = 0.5f;
  buf[2].left = 0.25f;
  buf[3].left = 0.125f;

  enc.push(buf, numFrames);

  REQUIRE(storage.getFrames().size() > 5);

  FlacDecoder dec(&storage, 3, 10);

  SampleFrame out[numFrames];
  dec.popAudio(out, numFrames);

  REQUIRE(out[0].left == Approx(1.0f));
  REQUIRE(out[1].left == Approx(0.5f));
  REQUIRE(out[2].left == Approx(0.25f));
  REQUIRE(out[3].left == Approx(0.125f));
}

TEST_CASE("FlacDecoder In=Out")
{
  auto numFrames = 4096;

  FlacFrameStorage storage(100000);
  FlacEncoder enc(48000, [&](auto frame, auto header) { storage.push(std::move(frame), header); });

  SampleFrame in[numFrames + 1];
  SampleFrame out[numFrames];

  g_random_set_seed(0);

  for(int i = 0; i < numFrames; i++)
  {
    in[i].left = g_random_double_range(-1, 1);
    in[i].right = g_random_double_range(-1, 1);
  }

  enc.push(in, numFrames + 1);

  FlacDecoder dec(&storage, 0, std::numeric_limits<FrameId>::max());
  auto res = dec.popAudio(out, numFrames);

  REQUIRE(res == 4096);

  for(int i = 0; i < numFrames; i++)
  {
    REQUIRE(Approx(in[i].left) == out[i].left);
    REQUIRE(Approx(in[i].right) == out[i].right);
  }
}

TEST_CASE("Recorder Ring")
{
  RingBuffer<int> ring(50);

  int inVal = 0;
  int outVal = 0;

  for(auto i = 0; i < 1000; i++)
  {
    auto numIn = g_random_int_range(1, ring.getFreeSpace());
    int in[numIn];
    std::generate(in, in + numIn, [&] { return inVal++; });
    ring.push(in, numIn);

    auto numOut = g_random_int_range(1, ring.avail());
    int out[numOut];
    numOut = ring.pop(out, numOut);

    for(auto k = 0; k < numOut; k++)
    {
      if(out[k] != outVal)
        G_BREAKPOINT();

      REQUIRE(out[k] == outVal);
      outVal++;
    }
  }
}

TEST_CASE("Recorder InOut")
{
  auto sr = 44100;
  auto recordLength = 10;  // seconds
  auto numFrames = sr * recordLength;
  auto chunkSize = 1000;
  auto numChunks = numFrames / chunkSize;

  Recorder r(sr);

  SampleFrame in[numFrames];

  g_random_set_seed(0);

  for(auto i = 0; i < numFrames; i++)
  {
    in[i].left = g_random_double_range(-1, 1);
    in[i].right = g_random_double_range(-1, 1);
  }

  auto inWalker = in;
  for(auto i = 0; i < numChunks; i++)
  {
    r.process(inWalker, chunkSize);
    r.getInput()->TEST_waitForSettling();
    inWalker += chunkSize;
  }

  r.getInput()->TEST_waitForSettling();

  r.getInput()->togglePause();
  auto first = r.getStorage()->getFrames().front()->id;
  r.getOutput()->setPlayPos(first);
  r.getOutput()->start();

  REQUIRE(first == 3);

  SampleFrame out[numFrames];
  std::fill(out, out + numFrames, SampleFrame { 0, 0 });

  auto outWalker = out;

  // don't be exact with the number of chunks here, because a chunk is only commited
  // at boundaries of 4096, so it may happen, that there are less chunks popped then pushed
  for(auto i = 0; i < numChunks / 2; i++)
  {
    r.getOutput()->TEST_waitForBuffersFilled(chunkSize);
    r.process(outWalker, chunkSize);
    outWalker += chunkSize;
  }

  // don't be exact with the number of frames here, because a frames
  // can only be generated by 'fuill' frames at frame boundaries
  for(auto i = 0; i < numFrames / 4; i++)
  {
    REQUIRE(Approx(in[i].left) == out[i].left);
    REQUIRE(Approx(in[i].right) == out[i].right);
  }
}

TEST_CASE("Bitstream")
{
  auto numBytes = 2000;
  std::vector<uint8_t> buffer(numBytes);
  memset(buffer.data(), 0, buffer.size());

  Bitstream writer(buffer);
  Bitstream reader(buffer);
  writer.seek(123);
  writer.patch(12, 0xFFFFFFFFFFFFFFFF);

  reader.seek(120);
  REQUIRE(reader.read(3) == 0);
  REQUIRE(reader.read(12) == 0xFFF);
  REQUIRE(reader.read(5) == 0);

  writer.patch(7, 100);

  reader.seek(120 + 3 + 12);
  REQUIRE(reader.read(7) == 100);
}

TEST_CASE("Bitstream on FlacHeader")
{
  // audacity egnerated header
  std::vector<uint8_t> flacHeader
      = { 0x66, 0x4c, 0x61, 0x43, 0x00, 0x00, 0x00, 0x22, 0x10, 0x00, 0x10, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
          0x0a, 0xc4, 0x42, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04, 0xe9, 0x80,
          0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e, 0x84, 0x00, 0x00, 0x28, 0x20, 0x00, 0x00, 0x00, 0x72, 0x65, 0x66, 0x65,
          0x72, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x6c, 0x69, 0x62, 0x46, 0x4c, 0x41, 0x43, 0x20, 0x31, 0x2e, 0x33, 0x2e,
          0x33, 0x20, 0x32, 0x30, 0x31, 0x39, 0x30, 0x38, 0x30, 0x34, 0x00, 0x00, 0x00, 0x00 };

  Bitstream s(flacHeader);
  REQUIRE(s.read(8) == 'f');
  REQUIRE(s.read(8) == 'L');
  REQUIRE(s.read(8) == 'a');
  REQUIRE(s.read(8) == 'C');
  REQUIRE(s.read(1) == 0);          // not the last meta data block
  REQUIRE(s.read(7) == 0);          // block type STREAMINFO
  REQUIRE(s.read(24) == 34);        // header length
  REQUIRE(s.read(16) == 4096);      // min block size
  REQUIRE(s.read(16) == 4096);      // max block size
  REQUIRE(s.read(24) == 0xffffff);  // min frame size
  REQUIRE(s.read(24) == 0);         // max frame size
  REQUIRE(s.read(20) == 44100);     // sample rate
  REQUIRE(s.read(3) == 1);          // num channels - 2
  REQUIRE(s.read(5) == 15);         // bits - 1
  REQUIRE(s.read(36) == 0);         // numFrames

  Bitstream patchLength(flacHeader);
  patchLength.seek(172);
  patchLength.patch(36, 1234567890);

  Bitstream check(flacHeader);
  REQUIRE(check.read(8) == 'f');
  REQUIRE(check.read(8) == 'L');
  REQUIRE(check.read(8) == 'a');
  REQUIRE(check.read(8) == 'C');
  REQUIRE(check.read(1) == 0);            // not the last meta data block
  REQUIRE(check.read(7) == 0);            // block type STREAMINFO
  REQUIRE(check.read(24) == 34);          // header length
  REQUIRE(check.read(16) == 4096);        // min block size
  REQUIRE(check.read(16) == 4096);        // max block size
  REQUIRE(check.read(24) == 0xffffff);    // min frame size
  REQUIRE(check.read(24) == 0);           // max frame size
  REQUIRE(check.read(20) == 44100);       // sample rate
  REQUIRE(check.read(3) == 1);            // num channels - 2
  REQUIRE(check.read(5) == 15);           // bits - 1
  REQUIRE(check.read(36) == 1234567890);  // numFrames
}